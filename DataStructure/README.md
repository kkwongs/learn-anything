# Data Structure

## 자료 구조란?

실행시간과 메모리 용량을 최소화하기 위해 효율적인 접근 및 수정을 가능케 하는 데이터의 관리를 의미한다.

## 자료 구조 종류

- Array vs Linked List
- Stack & Queue
- Tree
- Heap
- Hash Table
- Graph

## Array vs Linked List
선형 자료구조
### Array

논리적 저장 순서와 물리적 저장 순서가 같아서 인덱스로 해당 원소에 접근할 수 있다. 따라서 찾고자 하는 원소의 인덱스를 알고 있으면 O(1)로 접근할 수 있다.

하지만 삭제 또는 삽입 시 추가적인 작업이 필요하다. O(1)로 해당 원소에 접근하여 삭제하면 빈 공간이 생기기 때문에 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift 해줘야 하는 비용이 발생하고 시간 복잡도는 O(n)이 된다. 삽입 시에도 공간을 만들어줘야 하기 때문에 삽입할 공간과 그보다 큰 인덱스를 갖는 원소들을 shift 해줘야 하므로 시간 복잡도는 O(n)이 된다.

### Linked List

Array의 삭제와 삽입에 대한 문제를 해결하기 위한 자료구조가 Linked List이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 삭제와 삽입 시 O(1)의 시간으로 해결할 수 있다.

하지만 Array와 달리 논리적 저장 순서와 물리적 저장 순서가 달라서 원하는 원소를 Search하기 위해서는 첫 번째 원소부터 다 확인해봐야 한다. 이 과정에서 O(n)의 시간이라는 추가적인 작업이 필요하다.

결국 Linked List는 Search, 삭제, 삽입에 대해서 O(n)의 시간복잡도를 갖는다. Array보다 좋지 않은 시간복잡도를 가짐에도 불구하고 Linked List는 Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때 유용성이 드러나기 때문에 우리가 학습하는 것이다.

## Stack & Queue
선형 자료구조
### Stack
Last In First Out(LIFO) - 나중에 들어간 원소가 먼저 나온다. 또는 First In Last Out(FILO) - 먼저 드어간 원소가 나중에 나온다. 이것이 Stack의 가장 큰 특징이다.

### Queue
First In First Out(FIFO) - 먼저 들어간 원소가 먼저 나온다. Stack과는 반대로 먼저 들어간 원소가 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다.

## Tree

트리는 비선형 자료구조로 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조이다. 

#### 트리를 구성하고 있는 구성요소들(용어)

- Node(노드): 트리를 구성하고 있는 각각의 요소
- Edge(간선): 트리를 구성하기 위해 노드와 노드를 연결하는 선
- Root Node(루트 노드): 트리 구조에서 최상위에 있는 노드
- Terminal Node(= Leaf Node, 단말 노드): 하위에 다른 노드가 연결되어 있지 않은 노드
- Internal Node(내부 노드, 비단말 노드): 단말 노드를 제외한 모든 노드로 루트 노드를 포함

### Binary Tree(이진 트리)

루트 노드르 중심으로 두 개의 서브 트리로 나뉘어 진다. 또한 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다. 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, Leaf node에 다다랐을때, 정의가 만족되기 때문이다. 자연스럽게 노드가 하나 뿐인 것도 이진 트리 정의에 만족하게 된다.

트리에서는 각 층별로 숫자를 매겨서 이를 트리의 `Level(레벨)`이라고 한다. 레벨의 값은 0부터 시작하고 따라서 루트 노드의 레벨은 0이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 `height(높이)`라고 한다.

#### Perfect Binary Tree(포화 이진 트리), Complete Binary Tree(완전 이진 트리), Full Binary Tree(정 이진 트리)

모든 레벨이 꽉 찬 이진트리를 가리켜 `포화 이진 트리`라고 한다.

위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 `완전 이진 트리`라고 한다.

모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가리켜 `정 이진 트리`라고 한다.

배열로 구성된 Binary Tree는 노드의 개수가 n개이고 root가 0이 아닌 1에서 시작할 때, i번 째 노드에 대해서 parent(i) = i / 2, left_child(i) = 2 * i, right_child(i) = 2 * i + 1 의 index값을 갖는다.

### BST(Binary Search Tree)

이진 탐색 트리는 이진트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.

```
규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
규칙 4. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
```

이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해 갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 `Skewed Tree(편향 트리)`가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case가 되고 시간 복잡도는 O(n)이 된다.

배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 `Rebalnacing기법`이 등장하였다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 뒤에서 살펴볼 `Red-Black Tree`이다.


## Heap

## Hash Table

## Graph